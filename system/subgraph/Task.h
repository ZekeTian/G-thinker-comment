//########################################################################
//## Copyright 2018 Da Yan http://www.cs.uab.edu/yanda
//##
//## Licensed under the Apache License, Version 2.0 (the "License");
//## you may not use this file except in compliance with the License.
//## You may obtain a copy of the License at
//##
//## //http://www.apache.org/licenses/LICENSE-2.0
//##
//## Unless required by applicable law or agreed to in writing, software
//## distributed under the License is distributed on an "AS IS" BASIS,
//## WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//## See the License for the specific language governing permissions and
//## limitations under the License.
//########################################################################

/**
 *  任务，一个 Comper 会处理多个 task 
 */

#ifndef TASK_H_
#define TASK_H_

#include "Subgraph.h"
#include "adjCache.h"
#include "util/serialization.h"
#include "util/ioser.h"
#include "Comper.h"
#include "TaskMap.h"

using namespace std;

template <class VertexT, class ContextT = char>
class Task {
public:
	typedef VertexT VertexType;
	typedef typename VertexT::KeyType KeyT;
	typedef typename VertexT::ValueType ValueT;
	typedef typename VertexT::HashType HashT;
	typedef ContextT ContextType;

    typedef Task<VertexT, ContextT> TaskT;
	typedef Subgraph<VertexT> SubgraphT;

	typedef AdjCache<TaskT> CTable;
	typedef hash_map<KeyT, VertexT*> VTable;

	typedef TaskMap<TaskT> TaskMapT;


	SubgraphT subG;
	ContextT context;
	HashT hash;

	//internally used:
    /**
     * 下一轮迭代中需要拉取的顶点的 id
     */
	vector<KeyT> to_pull; //vertices to be pulled for use in next round 下一轮迭代中需要拉取的顶点的 id
	//- to_pull needs to be swapped to old_to_pull, before calling compute(.) that writes to_pull
	//- unlock vertices in old_to_pull

    /**
     * 存储拉取到的顶点，这些顶点在下轮迭代中使用。如果其中第 i 个顶点是远程顶点，需要通过发送消息拉取，则在 frontier_vertexes 中第 i 个位置为 NULL
     */
	vector<VertexT *> frontier_vertexes; //remote vertices are replaced with NULL

    /**
     * 已经拉取到本地的顶点数量（即在待拉取的顶点中，有 met_counter 个顶点已经拉取到本地）
     */
	atomic<int> met_counter; //how many requested vertices are at local, updated by comper/RespServer, not for use by users (system only)

	Task(){}

	Task(const Task & o)
	{
		//defined so that "met_counter" is no longer a problem when using vector<TaskT>
		subG = o.subG;
		context = o.context;
		hash = o.hash;
		to_pull = o.to_pull;
	}

	inline size_t req_size()
	{
		return frontier_vertexes.size();
	}

	/*//deprecated, now Task has no UDF, all UDFs are moved to Comper
	//will be set by Comper before calling compute(), so that add_task() can access comper's add_task()
	virtual bool compute(SubgraphT & g, ContextType & context, vector<VertexType *> & frontier) = 0;
	*/

	//to be used by users in UDF compute(.)
	void pull(KeyT id){
		to_pull.push_back(id);
	}

    /**
     * 拉取顶点。
     * 如果该任务需要从远程 worker 中拉取顶点（或已经从响应中获取到了顶点数据，但是该任务当前迭代不能继续处理），则返回 false；
     * 如果该任务需要的顶点已经全部拉取到本地，则返回 true，可以继续下一轮迭代。
     */
	//after task.compute(.) returns, process "to_pull" to:
	//set "frontier_vertexes"
	bool pull_all(thread_counter & counter, TaskMapT & taskmap) //returns whether "no need to wait for remote-pulling"
	{//called by Comper, giving its thread_counter and thread_id
		long long task_id = taskmap.peek_next_taskID();
		CTable & vcache = *(CTable *)global_vcache;
		VTable & ltable = *(VTable *)global_local_table;
		met_counter = 0;
		bool remote_detected = false; //two cases: whether add2map(.) has been called or not
		int size = to_pull.size();
		frontier_vertexes.resize(size);
		for(int i=0; i<size; i++)
		{
			KeyT key= to_pull[i];
			if(hash(key) == _my_rank) //in local-table 在本地顶点列表中
			{
				frontier_vertexes[i] = ltable[key];
				met_counter++;
			}
			else //remote 在远程 worker 中
			{
				if(remote_detected) //no need to call add2map(.) again 
				{
					frontier_vertexes[i] = vcache.lock_and_get(key, counter, task_id);
					if(frontier_vertexes[i] != NULL) met_counter++; // 第 i 个顶点已经拉取到本地，则 met_counter 加 1
				}
				else
				{
					frontier_vertexes[i] = vcache.lock_and_get(key, counter, task_id,
											taskmap, this);
					if(frontier_vertexes[i] != NULL) met_counter++;
					else //add2map(.) is called
					{
						remote_detected = true; // 本地的 local 和 cache 中都无法找到相应的顶点，则需要去远程 worker 中拉取顶点
					}
				}
			}
		}
		if(remote_detected)
		{
			//so far, all pull reqs are processed, and pending resps could've arrived (not wakening the task)
			//------
			conmap2t_bucket<long long, TaskT *> & bucket = taskmap.task_map.get_bucket(task_id); // 挂起的 task
			bucket.lock();
			hash_map<long long, TaskT *> & kvmap = bucket.get_map();
			auto it = kvmap.find(task_id);
			if(it != kvmap.end())
			{
				if(met_counter == req_size()) // 所有需要的顶点都已拉取到
				{//ready for task move, delete
					kvmap.erase(it); // 将 task 从挂起任务列表中删除，并加入到就绪任务列表中
					taskmap.task_buf.enqueue(this); 
				}
				//else, RespServer will do the move 所需要的顶点未拉取完，RespServer 负责摘取远程顶点
			}
			//else, RespServer has already did the move
			bucket.unlock();
			return false;//either has pending resps, or all resps are received but the task is now in task_buf (to be processed, but not this time) 远程请求未返回 或 远程请求已经返回但是当前任务不在 task_buf 中
		}
		else return true; //all v-local, continue to run the task for another iteration 所有顶点数据已全部拉取本地，可以继续下一轮迭代
	}

	void unlock_all()
	{
		CTable & vcache = *(CTable *)global_vcache;
		for(int i=0; i<frontier_vertexes.size(); i++)
		{
			VertexT * v = frontier_vertexes[i];
			if(hash(v->id) != _my_rank) vcache.unlock(v->id);
		}
	}

	//task_map => task_buf => push_task_from_taskmap() (where it is called)
	void set_pulled() //called after vertex-pull, to replace NULL's in "frontier_vertexes"
	{
		CTable & vcache = *(CTable *)global_vcache;
		for(int i=0; i<to_pull.size(); i++)
		{
			if(frontier_vertexes[i] == NULL)
			{
				frontier_vertexes[i] = vcache.get(to_pull[i]);
			}
		}
	}

	friend ibinstream& operator<<(ibinstream& m, const Task& v)
	{
		m << v.subG;
		m << v.context;
		m << v.to_pull;
		return m;
	}

	friend obinstream& operator>>(obinstream& m, Task& v)
	{
		m >> v.subG;
		m >> v.context;
		m >> v.to_pull;
		return m;
	}

	friend ifbinstream& operator<<(ifbinstream& m, const Task& v)
	{
		m << v.subG;
		m << v.context;
		m << v.to_pull;
		return m;
	}

	friend ofbinstream& operator>>(ofbinstream& m, Task& v)
	{
		m >> v.subG;
		m >> v.context;
		m >> v.to_pull;
		return m;
	}
};

#endif /* TASK_H_ */
